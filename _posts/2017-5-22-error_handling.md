---
title: 关于错误处理的思考
comments: true
layout: markdown
keyword: error, handle, goto, try, catch, errno, return
---

# 关于错误处理的思考

--------------------------------------
## 0、 麻烦的错误处理问题
最近在c语言中构建的代码的时候，总是烦于各种各样的错误应该怎么处理。比如说，每次分配内存都有可能会失败，从程序健壮性的角度来看，每次都必须检查内存分配是否成功，如果失败的话，要做对应的处理；再者，调用一个标准库或者第三方库，必须要确认其是否成功，然后对其错误做相关的处理。

这样一来，为了完成某个程序功能，你需要面对一堆可能出现的错误：标准io出错了，得知道什么错误，然后要么返回错误号，要么写log；第三方的什么出错了，也得知道出了什么错，然后要么返回错误号，要么打log。

可能某个函数的主要功能实现本来思路很清晰，但是无赖，可能出现各种各样的错误，那就很无赖蛋疼了；最后程序逻辑可能是这个样子的：

```c
int func1()
{
	ret = call_lib1();
	if (ret != 0) {
		log(...);
		free(data1);
		return lib1_ret1;
	}

	ret = call_lib2();
	if(ret != 0) {
		log(...);
		free(data2);
		free(data1);
		close1();
		return lib2_ret2;
	}

	do_something(mydata);
	if (mydata != a) {
		release_lib1();
		release_lib2();
		release_my_data();
		return myerr_1;
	}

	do_something2(mydata2);
//...
}

```
这还只是一个简单的函数，会有这么多的返回值。

写这个函数的人，要做什么事情呢？
* 每次调用函数都要处理一堆错误，可能还要释放一堆资源；如果多处需要用到调用，还要多处做同样的处理。（不想做个程序猿了。。。感觉像是个堆砖的码工。。。）
* 本来程序主要逻辑很简单，但是面对错误，每个逻辑点后要加一堆错误处理；最后代码又臭又长，可读性非常差。
* 不仅是错误处理，某些程序出错后，要求清理现场，记录错误，返回；某些是要求，忽略继续执行；某些则是要求改一下参数，继续来，或者执行个别的过程，然后重来，或者执行个别的函数获得错误号。。。。（心真的好累）
* 调用某个库时，可能还要检查输入参数是否正确，不正确，再告诉调用者，参数不正确。

我调用这个函数的caller，要面对的到底是什么呢？
* 一堆来自各种库的错误号
* 这些来自各种库的错误号，还可能重合（这个库-1表示io出错，那个库-1表示内存分配失败）
* 被call的函数自己可能也要定义一堆错误，也有可能和其他库重合

那为了写好一个程序，我们总共面对哪些问题：
1. 如何高效的处理错误，避免重复的书写错误处理的过程
2. 如何正确的记录错误：写log，还是return错误号；return 错误号的话，重叠的错误号怎么办
3. 要不要检查输入参数

## 0.1 多级调用中的错误处理
在多级的调用中，如果最下层的调用出现了问题，会导致调用链条的失败。而根据业务的逻辑，有可能，底层的错误号会被要求最上层处理，也有可能被中间层处理。

而程序要做的事情：如果是中间层处理，则相对容易；如果被最上层处理，则要求错误被传到最上层，因此中间层每层都要判断是否发生了这个错误。

这当中会有很多问题：
1. 错误得有全局错误号，局部的错误号，会使中间层无法识别，即使中间层识别了，中间层可能还需要转换错误号，使别的层识别。
2. 错误传到上层，每个中间层都要支持，向上传递的逻辑：可能要求中间层返回错误的方式相同，比如说都要返回int类型的错误号。（写代码真是下一盘大棋。。）

有时想想异常真是好东西。有了异常机制，中间层根本不用管这些个错误了；谁关心谁catch，上层直接catch一类错，下层就可能完全不检查了：开心的写吧！我们不用每次都检查处理这个恶心的错了，跑飞了，自然有人管。

举个例子，内存分配错误：下层任何分配内存的行为都有可能出错，如果没有异常，我们可能每层都要检查是否有内存分配错误；一旦出了错，每层都要检测并传递给上层，这是多么令人操心又烦心的事情（送佛送到西。。。送错也要好好的每层都要用狗眼看看错误大爷，然后好吃好喝，送给上层）。有了异常就不一样了，“啊？内存出错？我们不管的！扔掉！啊？别人扔了东西？那我也扔！啥东西？跟我没关系，看都不看扔了！”一直到最上层，“啊？有异常？catch一下是不是内存分配错误，哦？是你小子啊，看我怎么收拾你！”整个程序只要有一处catch就好了，其它地方根本无视，认为没这个东西存在。

程序员的角度看，c和c++的内存分配的区别：
c程序员： malloc以下，看是不是NULL；是NULL， return ERR_MEM;调用的函数，ret ==  ERR_MEM， 再return ERR_MEM；处理的函数，ret == ERR_MEM？哦！log（“no mem”），do_if_memout()；

c++程序员：new Item1, “啊？会不会分配不成功？有这种事情？我不管的。错了new会自己扔异常，我啥都不用做，最多main里面catch下“。

c程序员想哭。。。。

## 1. 写代码的哲学问题
1. 谁分配谁释放，谁污染谁处理原则
2. 集中于主要逻辑，错误另外（从主逻辑中拎出来）处理

## 2. c风格的错误处理和c++风格的错误处理


## 3. 道理我都懂，但是应该怎么做呢？

### 3.1 使用err_base + lib_errcode来设置全局错误号 (自己使用不带偏移的base的错误号)

### 3.2 使用goto来重用错误处理代码，并将错误赶出主要任务逻辑

### 3.3 区分调用者和被调用者，及库函数还是程序主过程函数

### 3.4 尽量使用同一中错误返回逻辑








